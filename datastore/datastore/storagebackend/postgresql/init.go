package postgresql

import (
	"datastore/common"
	"datastore/datastore"
	"fmt"
	"log"
	"reflect"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"
)

// package variables (only accessible within postgresql package)
var (
	cleanupInterval time.Duration // minimum time period between calls to cleanup()
	lastCleanupTime time.Time     // time of last call to cleanup()

	putObsLimit int // max # of observations in a single call to PutObservations

	tsInt64StructFields []reflect.StructField // applicable time series metadata struct fields
	// of type int64
	tsStringStructFields []reflect.StructField // applicable time series metadata struct fields
	// of type string

	tsInt64MdataGoNames []string // Go names for time series metadata of type int64
	tsInt64MdataPBNames []string // protobuf names for time series metadata of type int64

	tsStringMdataGoNames []string // Go names for time series metadata of type string
	tsStringMdataPBNames []string // protobuf names for time series metadata of type string

	tsMdataPBNamesUnique []string // column names of constraint unique_main in table time_series

	obsInt64Pb2go map[string]string // association between observation specific protobuf name and
	// (generated by protoc) Go name
	// NOTES:
	// - Protobuf names are field names of the ObsMetadata message in datastore.proto.
	// - Only fields of type int64 are included.
	// - The observation value field is not included.
	// - Protobuf names are identical to corresponding database column names.
	// - Protobuf names are snake case (aaa_bbb) whereas Go names are camel case (aaaBbb or AaaBbb).

	obsStringPb2go map[string]string // same as obsInt64Pb2go, except that only fields of type
	// string are included

	obsInt64MdataGoNames  []string // Go names for observation metadata of type int64
	obsStringMdataGoNames []string // Go names for observation metadata of type string

	obsInt64MdataCols  []string // column names qualified with table name 'observation' for
	// metadata of type int64
	obsStringMdataCols []string // column names qualified with table name 'observation' for
	// metadata of type string

	pbInt642table map[string]string // association between a protobuf name and a table name
	// NOTES:
	// - Protobuf names are field names of *either* the ObsMetadata *or* the TSMetadata message in
	//   datastore.proto. As a consequence, the same field name may not occur in both messages.
	// - Only fields of type int64 are included.
	// - The observation value field is not included.
	// - Protobuf names are identical to corresponding database column names.
	// - Protobuf names are snake case (aaa_bbb).

	pbString2table map[string]string // same as pbInt642table, except that only fields of type
	// string are included

	pbInt642tableKeys []string // for error reporting for fields of type int64
	pbString2tableKeys []string // for error reporting for fields of type string

	supReflFilterFields common.StringSet // fields supported by general, reflectable filter
	supReflFilterFieldsSorted []string // supReflFilterFields as a sorted list

	tspb2go map[string]string // association between time series specific protobuf name and
	// (generated by protoc) Go name.
	// NOTES:
	// - Protobuf names are field names of the TSMetadata message in datastore.proto.
	// - Protobuf names are identical to corresponding database column names.
	// - Protobuf names are snake case (aaa_bbb) whereas Go names are camel case (aaaBbb or AaaBbb).

	// used by upsertTS
	upsertTSInsertCmd, upsertTSSelectCmd string

	// fields allowable in included_response_fields
	supIncRespFields    common.StringSet
	supIncRespFieldsCSV string

	// regular expression for an int64 range
	int64RangeRE *regexp.Regexp
)

// initCleanupInterval initializes cleanupInterval.
func initCleanupInterval() {
	name := "CLEANUPINTERVAL"
	defaultVal := int64(86400)
	val0 := strings.ToLower(common.Getenv(name, fmt.Sprintf("%d", defaultVal)))

	val, err := strconv.ParseInt(val0, 10, 64)
	if err != nil {
		log.Printf(
			"WARNING: failed to parse %s as an int64: %s; falling back to default secs: %d",
			name, val0, defaultVal)
		val = defaultVal
	}

	cleanupInterval = time.Duration(val) * time.Second
}

// initPutObsLimit initializes putObsLimit from environment variable PUTOBSLIMIT.
func initPutObsLimit() {
	name := "PUTOBSLIMIT"
	defaultLimit := 100000
	limitS := common.Getenv(name, fmt.Sprintf("%d", defaultLimit))

	var err error
	putObsLimit, err = strconv.Atoi(limitS)
	if (err != nil) || (putObsLimit < 1) {
		log.Printf(
			"WARNING: failed to parse %s as a positive integer: %s; falling back to default: %d",
			name, limitS, defaultLimit)
		putObsLimit = defaultLimit
	}
}

// init initializes package variables
func init() { // automatically called once on program startup (on first import of this package)

	initCleanupInterval()
	lastCleanupTime = time.Time{}

	initPutObsLimit()

	// create ts{Int64|String}StructFields
	tsInt64StructFields = []reflect.StructField{}
	for _, field := range reflect.VisibleFields(reflect.TypeOf(datastore.TSMetadata{})) {
		if field.IsExported() {
			switch field.Type.Kind() {
			case reflect.Int64:
				tsInt64StructFields = append(tsInt64StructFields, field)
			case reflect.String:
				tsStringStructFields = append(tsStringStructFields, field)
			}
		}
	}

	// create ts{Int64|String}MdataGoNames and ts{Int64|String}MdataPBNames
	tsStringMdataGoNames = []string{}
	tsStringMdataPBNames = []string{}
	for _, field := range reflect.VisibleFields(reflect.TypeOf(datastore.TSMetadata{})) {
		if field.IsExported() {
			goName := field.Name
			scGoName := common.ToSnakeCase(goName)
			switch field.Type.Kind() {
			case reflect.Int64:
				tsInt64MdataGoNames = append(tsInt64MdataGoNames, goName)
				tsInt64MdataPBNames = append(tsInt64MdataPBNames, scGoName)
			case reflect.String:
				tsStringMdataGoNames = append(tsStringMdataGoNames, goName)
				tsStringMdataPBNames = append(tsStringMdataPBNames, scGoName)
			}
		}
	}

	// create obs{Int64|String}Pb2go, obs{Int64|String}MdataGoNames, and obs{Int64|String}MdataCols
	obsStringPb2go = map[string]string{}
	obsStringMdataGoNames = []string{}
	obsStringMdataCols = []string{}
	for _, field := range reflect.VisibleFields(reflect.TypeOf(datastore.ObsMetadata{})) {
		if field.IsExported() &&
			(strings.ToLower(field.Name) != "value") { // obs value not considered metadata here!
			goName := field.Name
			pbName := common.ToSnakeCase(goName)
			switch field.Type.Kind() {
			case reflect.Int64:
				obsInt64Pb2go[pbName] = goName
				obsInt64MdataGoNames = append(obsInt64MdataGoNames, goName)
				obsInt64MdataCols = append(
					obsInt64MdataCols, fmt.Sprintf("observation.%s", pbName))
			case reflect.String:
				obsStringPb2go[pbName] = goName
				obsStringMdataGoNames = append(obsStringMdataGoNames, goName)
				obsStringMdataCols = append(
					obsStringMdataCols, fmt.Sprintf("observation.%s", pbName))
			}
		}
	}

	// create pbInt642table
	pbInt642table = map[string]string{}
	for _, pbName := range tsInt64MdataPBNames {
		pbInt642table[pbName] = "time_series"
	}
	for pbName := range obsInt64Pb2go {
		if _, found := pbInt642table[pbName]; found {
			panic(fmt.Sprintf(
				"precondition failed: int64 field %s in ObsMetadata already found in TSMetadata",
				pbName))
		}
		pbInt642table[pbName] = "observation"
	}

	// create pbString2table
	pbString2table = map[string]string{}
	for _, pbName := range tsStringMdataPBNames {
		pbString2table[pbName] = "time_series"
	}
	for pbName := range obsStringPb2go {
		if _, found := pbString2table[pbName]; found {
			panic(fmt.Sprintf(
				"precondition failed: string field %s in ObsMetadata already found in TSMetadata",
				pbName))
		}
		pbString2table[pbName] = "observation"
	}

	supReflFilterFields = common.StringSet{}

	// create pbInt642tableKeys
	pbInt642tableKeys = []string{}
	for key := range pbInt642table {
		pbInt642tableKeys = append(pbInt642tableKeys, key)
		supReflFilterFields.Set(key)
	}
	sort.Strings(pbInt642tableKeys)

	// create pbString2tableKeys
	pbString2tableKeys = []string{}
	for key := range pbString2table {
		pbString2tableKeys = append(pbString2tableKeys, key)
		supReflFilterFields.Set(key)
	}
	sort.Strings(pbString2tableKeys)

	supReflFilterFieldsSorted = supReflFilterFields.Values()
	sort.Strings(supReflFilterFieldsSorted)

	// create tspb2go
	tspb2go = map[string]string{}
	for _, field := range reflect.VisibleFields(reflect.TypeOf(datastore.TSMetadata{})) {
		if field.IsExported() && ((field.Type.Kind() == reflect.Int64) ||
			(field.Type.Kind() == reflect.String)) {
			// TODO: support non-reflectable types, like the 'links' attribute
			goName := field.Name
			pbName := common.ToSnakeCase(goName)
			tspb2go[pbName] = goName
		}
	}

	// create supIncRespFields and supIncRespFieldsValues
	supIncRespFields = common.StringSet{}
	// --- BEGIN TSMetadata fields -------------------
	for _, f := range tsStringMdataPBNames {
		supIncRespFields.Set(f)
	}
	supIncRespFields.Set("links")
	// --- END TSMetadata fields -------------------
	// --- BEGIN ObsMetadata fields -------------------
	for _, f := range obsStringMdataCols {
		supIncRespFields.Set(strings.TrimPrefix(f, "observation."))
	}
	supIncRespFields.Set("geo_point")
	supIncRespFields.Set("obstime_instant")
	supIncRespFields.Set("pubtime")
	supIncRespFields.Set("value")
	// --- END ObsMetadata fields -------------------
	sIRFVals := supIncRespFields.Values()
	sort.Strings(sIRFVals)
	supIncRespFieldsCSV = strings.Join(sIRFVals, ", ")

	// create int64RangeRE
	int64RangeRE = regexp.MustCompile("^(-?[0-9]+)/(-?[0-9]+)$")
}
