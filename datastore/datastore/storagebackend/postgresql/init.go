package postgresql

import (
	"datastore/common"
	"datastore/datastore"
	"fmt"
	"log"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"
)

// package variables (only accessible within postgresql package)
var (
	cleanupInterval time.Duration // minimum time period between calls to cleanup()
	lastCleanupTime time.Time     // time of last call to cleanup()

	putObsLimit int // max # of observations in a single call to PutObservations

	tsStructFields []reflect.StructField // applicable time series metadata struct fields

	tsStringMdataGoNames []string // Go names for time series metadata of type string
	tsStringMdataPBNames []string // protobuf names for time series metadata of type string
	tsStringMdataPBNamesUnique []string // column names of constraint unique_main in table
	// time_series

	obspb2go map[string]string // association between observation specific protobuf name and
	// (generated by protoc) Go name
	// NOTES:
	// - Protobuf names are field names of the ObsMetadata message in datastore.proto.
	// - Only fields of string type are included.
	// - The observation value field is not included.
	// - Protobuf names are identical to corresponding database column names.
	// - Protobuf names are snake case (aaa_bbb) whereas Go names are camel case (aaaBbb or AaaBbb).

	obsStringMdataGoNames []string // Go names for observation metadata of type string
	obsStringMdataCols    []string // column names qualified with table name 'observation'

	pb2table map[string]string // association between a protobuf name and a table name
	// NOTES:
	// - Protobuf names are field names of *either* the ObsMetadata *or* the TSMetadata message in
	//   datastore.proto. As a consequence, the same field name may not occur in both messages.
	// - Only fields of string type are included.
	// - The observation value field is not included.
	// - Protobuf names are identical to corresponding database column names.
	// - Protobuf names are snake case (aaa_bbb).

	pb2tableKeys []string // for error reporting

	tspb2go map[string]string // association between time series specific protobuf name and
	// (generated by protoc) Go name.
	// NOTES:
	// - Protobuf names are field names of the TSMetadata message in datastore.proto.
	// - Protobuf names are identical to corresponding database column names.
	// - Protobuf names are snake case (aaa_bbb) whereas Go names are camel case (aaaBbb or AaaBbb).

	// used by upsertTS
	upsertTSInsertCmd, upsertTSSelectCmd string
)

// initCleanupInterval initializes cleanupInterval.
func initCleanupInterval() {
	name := "CLEANUPINTERVAL"
	defaultVal := int64(86400)
	val0 := strings.ToLower(common.Getenv(name, fmt.Sprintf("%d", defaultVal)))

	val, err := strconv.ParseInt(val0, 10, 64)
	if err != nil {
		log.Printf(
			"WARNING: failed to parse %s as an int64: %s; falling back to default secs: %d",
			name, val0, defaultVal)
		val = defaultVal
	}

	cleanupInterval = time.Duration(val) * time.Second
}

// initPutObsLimit initializes putObsLimit from environment variable PUTOBSLIMIT.
func initPutObsLimit() {
	name := "PUTOBSLIMIT"
	defaultLimit := 100000
	limitS := common.Getenv(name, fmt.Sprintf("%d", defaultLimit))

	var err error
	putObsLimit, err = strconv.Atoi(limitS)
	if (err != nil) || (putObsLimit < 1) {
		log.Printf(
			"WARNING: failed to parse %s as a positive integer: %s; falling back to default: %d",
			name, limitS, defaultLimit)
		putObsLimit = defaultLimit
	}
}

// init initializes package variables
func init() { // automatically called once on program startup (on first import of this package)

	initCleanupInterval()
	lastCleanupTime = time.Time{}

	initPutObsLimit()

	// create tsStructFields
	tsStructFields = []reflect.StructField{}
	for _, field := range reflect.VisibleFields(reflect.TypeOf(datastore.TSMetadata{})) {
		if field.IsExported() && (field.Type.Kind() == reflect.String) {
			tsStructFields = append(tsStructFields, field)
		}
	}

	// create tsStringMdataGoNames and tsStringMdataPBNames
	tsStringMdataGoNames = []string{}
	tsStringMdataPBNames = []string{}
	for _, field := range reflect.VisibleFields(reflect.TypeOf(datastore.TSMetadata{})) {
		if field.IsExported() && (field.Type.Kind() == reflect.String) {
			goName := field.Name
			tsStringMdataGoNames = append(tsStringMdataGoNames, goName)
			tsStringMdataPBNames = append(tsStringMdataPBNames, common.ToSnakeCase(goName))
		}
	}

	// create obspb2go, obsStringMdataGoNames, and obsStringMdataCols
	obspb2go = map[string]string{}
	obsStringMdataGoNames = []string{}
	obsStringMdataCols = []string{}
	for _, field := range reflect.VisibleFields(reflect.TypeOf(datastore.ObsMetadata{})) {
		if field.IsExported() && (field.Type.Kind() == reflect.String) &&
			(strings.ToLower(field.Name) != "value") { // (obs value not considered metadata here)
			goName := field.Name
			pbName := common.ToSnakeCase(goName)
			obspb2go[pbName] = goName
			obsStringMdataGoNames = append(obsStringMdataGoNames, goName)
			obsStringMdataCols = append(obsStringMdataCols, fmt.Sprintf("observation.%s", pbName))
		}
	}

	// create pb2table
	pb2table = map[string]string{}
	for _, pbName := range tsStringMdataPBNames {
		pb2table[pbName] = "time_series"
	}
	for pbName := range obspb2go {
		if _, found := pb2table[pbName]; found {
			panic(fmt.Sprintf(
				"precondition failed: field %s in ObsMetadata already found in TSMetadata", pbName))
		}
		pb2table[pbName] = "observation"
	}

	// create pb2tableKeys
	pb2tableKeys = []string{}
	for key := range pb2table {
		pb2tableKeys = append(pb2tableKeys, key)
	}
	sort.Strings(pb2tableKeys)

	// create tspb2go
	tspb2go = map[string]string{}
	for _, field := range reflect.VisibleFields(reflect.TypeOf(datastore.TSMetadata{})) {
		if field.IsExported() && (field.Type.Kind() == reflect.String) {
			// TODO: support non-string types, like the 'links' attribute
			goName := field.Name
			pbName := common.ToSnakeCase(goName)
			tspb2go[pbName] = goName
		}
	}
}
